<script src="../lib/three.r70.min.js"></script>
<script src="../lib/TrackballControls.js"></script>

<style>
body {
  margin: 0;
  overflow: hidden;
}
</style>

<script>
"use strict";

var Vec3 = THREE.Vector3;

function writeVec3(buffer, i, vec) {
  buffer[i*3 + 0] = vec.x;
  buffer[i*3 + 1] = vec.y;
  buffer[i*3 + 2] = vec.z;
}

function Charge(value, position) {
  this.value = value;
  this.position = position;
}

Charge.prototype.electricFieldAt = function(point, v) {
  v.subVectors(point, this.position);
  v.setLength(this.value / v.lengthSq());
  return v;
};

function ChargeSystem() {
  this.charges = [];
}

ChargeSystem.prototype.addCharge = function (value, x, y, z) {
  this.charges.push(new Charge(value, new Vec3(x, y, z)));
};

ChargeSystem.prototype.electricFieldAt = function (point, v, w) {
  v.set(0, 0, 0);
  
  for (var i = 0; i < this.charges.length; ++i) {
    var field = this.charges[i].electricFieldAt(point, w);
    v.add(field);
  }
  
  return v;
};

ChargeSystem.prototype.isTooClose = function (point, limit) {
  for (var i = 0; i < this.charges.length; ++i) {
    var charge = this.charges[i];
    
    if (point.distanceTo(charge.position) < limit) {
      return true;
    }
  }
  
  return false;
};

function electricFieldLine(system, buffer, init, depth, near_lim, far_lim) {
  var position = init.clone();
  var v1 = new Vec3();
  var v2 = new Vec3();
  
  var count = 0;
  
  writeVec3(buffer, count++, position);
  
  for (var i = 1; i < depth + 1; ++i) {
    var field = system.electricFieldAt(position, v1, v2);
    field.normalize();
    
    position.add(field);
    
    writeVec3(buffer, count++, position);
    
    if (i % 10 == 0) {
      if (position.length() > far_lim) {
        break;
      }
      
      if (system.isTooClose(position, near_lim)) {
        break;
      }
    }
  }
  
  return count;
};

function electricFieldLineMany(system, init_points, depth, near_lim, far_lim) {
  console.profile('simulation');
  
  var buffer  = new Float32Array(3 * (depth + 1));
  var lines   = [];
  
  for (var i = 0; i < init_points.length; ++i) {
    var init = init_points[i];
    
    var count = electricFieldLine(system, buffer, init, depth, near_lim, far_lim);
    var vertices = new Float32Array(buffer.subarray(0, 3 * count));
    
    lines.push(vertices);
  }
  
  console.profileEnd();
  
  return lines;
};

function makeRotations(points, axis, rads, count) {
  var result = [];
  
  var slice = rads / count;
  var angle = 0;
  
  for (var i = 0; i < points.length; ++i) {
    var source = points[i];
    
    for (var j = 0; j < count; ++j) {
      var point = source.clone();
      point.applyAxisAngle(axis, angle);
    
      angle += slice;
      
      result.push(point);
    }
  }
  
  return result;
}

function xyCirclePoints(radius, count) {
  var source = new Vec3(0, radius, 0);
  var axis = new Vec3(0, 0, 1);
  
  return makeRotations([source], axis, 2 * Math.PI, count);
}

function xyzCirclePoints(radius, count, rotations) {
  var points = xyCirclePoints(radius, count);
  var axis = new Vec3(1, 0, 0);
  
  return makeRotations(points, axis, Math.PI, rotations);
}

var sphere_geometry = new THREE.SphereGeometry(10, 16, 16);
var sphere_material = new THREE.MeshNormalMaterial();

function placeChargeSphere(scene, charge) {
  var mesh = new THREE.Mesh(sphere_geometry, sphere_material);
  mesh.position.copy(charge.position);
  
  scene.add(mesh);
}

function placeLine(scene, vertices) {
  var material = new THREE.LineBasicMaterial({
    color: 0x0000FF
  });
  
  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
  
  var line = new THREE.Line(geometry, material);
  scene.add(line);
}

function work(scene, system) {
  var depth     = 100000;
  var near_lim  = 1;
  var far_lim   = 10000;
  
  var charges = system.charges;
  
  for (var i = 0; i < charges.length; ++i) {
    placeChargeSphere(scene, charges[i]);
  }
  
  var circle = xyzCirclePoints(5, 20, 1);
  var points = [];
  
  for (var i = 0; i < charges.length; ++i) {
    var charge = charges[i];
    
    if (charge.value < 0) continue;
    
    for (var j = 0; j < circle.length; ++j) {
      var point = new Vec3();
      point.addVectors(charge.position, circle[j]);
      points.push(point);
    }
  }
  
  var lines = electricFieldLineMany(system, points, depth, near_lim, far_lim);
  
  for (var i = 0; i < lines.length; ++i) {
    var vertices = lines[i];
    
    placeLine(scene, vertices);
  }
}

function init() {
  var camera, scene, renderer, controls;
  
  var camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 100000);
  camera.position.z = 1000;
  
  var scene = new THREE.Scene();
  
  function render() {
    renderer.render(scene, camera);
  }
  
  var renderer = new THREE.WebGLRenderer({alpha: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  var controls = new THREE.TrackballControls(camera);
  controls.addEventListener('change', render);
  
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
  }
  
  document.body.appendChild(renderer.domElement);
  
  var system = new ChargeSystem();
  system.addCharge(+1, +200, 0, 0);
  system.addCharge(-1, -200, 0, 0);
  
  work(scene, system);
  
  render();
  animate();
}

window.addEventListener('load', init);

</script>